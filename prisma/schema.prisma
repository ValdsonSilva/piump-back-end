generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------- ENUMS ---------- 
enum AccountType {
  INDIVIDUAL
  BUSINESS_CLIENT
}

enum EmployeeRole {
  OWNER
  STAFF
}

enum AMPM {
  AM
  PM
}

enum ServiceStatus {
  PENDING
  SCHEDULED
  CANCELED
  DONE
}

enum Plan {
  clean
  family
  fresh
  custom
}

enum ConversationRole {
  MEMBER
  ADMIN
}

// ---------- TABELAS CENTRAIS ---------- 
model User {
  id               String      @id @default(cuid())
  name             String
  email            String      @unique
  password         String
  phone            String
  accountType      AccountType @default(INDIVIDUAL)
  isAdmin          Boolean     @default(false)
  stripeCustomerId String?     @unique
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  businessClientProfile   BusinessClientProfile?
  servicesRequested       Service[]                 @relation("UserServices")
  Employee                Employee[]
  Address                 Address[]
  ConversationParticipant ConversationParticipant[]

  Message            Message[]
  MessageReadReceipt MessageReadReceipt[]
}

// Empresas compradoras (B2B Buyer)
model BusinessClientProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  businessName     String
  ein              String?
  businessCategory String?
  serviceNeeds     ServiceCategory[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Address Address[]
}

model Provider {
  id                 String            @id @default(cuid())
  email              String            @unique
  password           String
  phone              String
  isCompany          Boolean           @default(false)
  companyName        String
  registrationNumber String?
  approved           Boolean           @default(false)
  operatesAM         Boolean           @default(true)
  operatesPM         Boolean           @default(true)
  categoriesOffered  ServiceCategory[]
  employees          Employee[]
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt

  Service      Service[]
  Address      Address[]
  ZipWhitelist ZipWhitelist[]

  VerificationDocument VerificationDocument[]
}

model Address {
  id        String   @id @default(cuid())
  line1     String
  city      String
  state     String
  zip       String
  country   String   @default("US")
  lat       Float?
  lng       Float?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users     User[]
  providers Provider[]
  clients   BusinessClientProfile[]
}

model Employee {
  id         String       @id @default(cuid())
  providerId String
  provider   Provider     @relation(fields: [providerId], references: [id], onDelete: Cascade)
  name       String
  email      String
  phone      String?
  role       EmployeeRole @default(STAFF)
  active     Boolean      @default(true)
  userId     String?      @unique
  user       User?        @relation(fields: [userId], references: [id])
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  @@unique([providerId, email])
  @@index([providerId])
}

model ServiceCategory {
  id          Int                     @id @default(autoincrement())
  name        String                  @unique
  slug        String                  @unique
  providers   Provider[]
  clientNeeds BusinessClientProfile[]
  bookings    Service[]
}

model VerificationDocument {
  id         String   @id @default(cuid())
  providerId String
  provider   Provider @relation(fields: [providerId], references: [id])
  url        String
  status     String   @default("PENDING")
  uploadedAt DateTime @default(now())
}

model ZipWhitelist {
  zip       String   @id
  city      String?
  state     String?
  active    Boolean  @default(true)
  createdAt DateTime @default(now())

  providers Provider[]
}

model Service {
  id                    String          @id @default(cuid())
  bookingCode           String          @unique
  requesterId           String
  requester             User            @relation("UserServices", fields: [requesterId], references: [id])
  providerId            String?
  provider              Provider?       @relation(fields: [providerId], references: [id])
  categoryId            Int
  category              ServiceCategory @relation(fields: [categoryId], references: [id])
  serviceZip            String?
  ampm                  AMPM
  sameDay               Boolean         @default(false)
  assignedDate          DateTime?
  status                ServiceStatus   @default(PENDING)
  stripePaymentIntentId String?         @unique
  stripeSubscriptionId  String?         @unique
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  binCleaningDetails    ServiceDetails?
  Conversation          Conversation[]

  @@index([categoryId, serviceZip, status])
  @@index([assignedDate, status])
  @@index([requesterId])
  @@index([providerId])
}

model ServiceDetails {
  serviceId   String  @id @map("serviceId")
  service     Service @relation(fields: [serviceId], references: [id])
  bins        Int?
  plan        Plan?
  description String?
}

model Conversation {
  id               String                    @id @default(cuid())
  serviceId        String?                   @unique
  service          Service?                  @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  createdAt        DateTime                  @default(now())
  participants     ConversationParticipant[]
  messages         Message[]
  ConversationMeta ConversationMeta?

  @@index([createdAt])
}

model ConversationParticipant {
  id             String           @id @default(cuid())
  conversationId String
  userId         String
  role           ConversationRole @default(MEMBER)
  createdAt      DateTime         @default(now())
  conversation   Conversation     @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId, createdAt])
}

model Message {
  id                 String               @id @default(cuid())
  conversationId     String
  senderId           String
  content            String
  createdAt          DateTime             @default(now())
  conversation       Conversation         @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender             User                 @relation(fields: [senderId], references: [id], onDelete: Cascade)
  MessageReadReceipt MessageReadReceipt[]

  @@index([conversationId, createdAt])
  @@index([senderId, createdAt])
  @@index([conversationId, id]) // novo
}

// ---------- OUTBOX & CHAT EXTRAS ----------
model OutboxEvent {
  id             String    @id @default(cuid())
  topic          String    // nome do evento
  payload        Json      // dados passados no evento
  // para idempotência de produtores (clients web/mobile), opcional:
  idempotencyKey String?   @unique
  // para orquestração/retentativas:
  status         String    @default("PENDING") // PENDING|SENT|FAILED
  attempts       Int       @default(0) // em erro soma-se +1 em tentativas
  error          String?
  createdAt      DateTime  @default(now())
  availableAt    DateTime  @default(now()) // para backoff/retentativa
  sentAt         DateTime?

  @@index([status, availableAt])
}

// confirmações de leitura (opcional, mas recomendado)
model MessageReadReceipt {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([userId, readAt])
}

// qualidade de vida p/ lista de conversas (opcional)
model ConversationMeta {
  conversationId String       @id
  lastMessageAt  DateTime
  lastMessageId  String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([lastMessageAt])
}
